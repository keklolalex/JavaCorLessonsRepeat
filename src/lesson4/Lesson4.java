package lesson4;



public class Lesson4 {
    public static void main(String[] args) {
        //примитивные типы данных и ссылочные
        //Char - примитивный тип данных - 16 бит  - занимает 1 символ Unicode

        char char1 = 'J'; //именно символ 1 шт в ' ' ковычках, если в " " уже строка ссылочный тип String
        char char2 = 74; //по таблице Unicode можно записать номер символа, у J - 74, диапазон от 0 до 65535
        // https://unicode-table.com/en/#0074 таблица
        char char3 = '\u0044'; //16ричное представление в escape последовательности
        System.out.println(char1);
        System.out.println(char2);
        System.out.println(char3);
        // \n символ переноса строки применяется в print

        //Строка - упорядоченная последовательность символов в " " ковычках
        //Строка - ссылочный тип, экземпляр класса String
        //Создание строк
        //1. в двойных ковычках "Строка"
        //2. через конструктор (позволяют создать сущности String) new String() - используется только, если
        //создание строки через " " невозможен
            // можно создать строки из строки с ковычками "", набора byte, char и из кодировок

        //строки неизменны, можно лишь создать новую на основе существующих
        //строка -> СТРОКА -> СтрокА

        //хранение строк до 9 версии Java: массив сhar в кодировке UTF-16,
        //где каждый char был представлен двумя байтами

        //[00, 01, 32, 53] для кирилицы
        //[00, 01, 02, 03] для латиницы
        //Хранение строк начиная с Java 9: массив byte в кодировке UTF-16 или кодировки LATIN-1

        String string1 = "Строка";
        String string2 = "Строка";
        // строки созданые выше попадают в пул

        String string3 = new String("Строка");
        //строки созданные через конструктор не попадают в пул строк, а попадают в heap память

        //все ссылочные типы хранятся в heap памяти (куча, область памяти)
        //в heap памяти находится пул строк

        //ссылочные типы не сравнивают через ==
        //т.к. оператор == сравнивает ссылки, а не фактические данные
        System.out.println(string1 == string2); //true // сравнивает область памяти пула строк в одной области памяти
        System.out.println(string1 == string3); //false //сравнивает ссылки, но они в разных областях памяти в пуле и heap

        //интернирование строк - помещаем строку в пулл (из кучи, из конструктора) в обьект
        String interString = string3.intern(); // копирует из кучи в пулл память если там нет такого значения
        //тем самым создает из обьекта переменную как бы

        System.out.println(interString == string1); //true

        // Сравнение строк:
        //строчку которую хотим сравнить (значение - номера символов в Unicode), пишем, точка,
                // вызываем метод equals(//и сюда пишем другую строку)
        // с учетом регистра - true если равны по значение, false если разные
        System.out.println(string1.equals(string2)); //сравнение с учетом регистра
        System.out.println(string1.equalsIgnoreCase(string2)); // сравнение без учета регистра

        //для нескольких строк надо писать метод с if
        //известная ошибка
        string2 = null;
        //System.out.println(string2.equals("Строка")); //java.lang.NullPointerException, потому что нет ничего в обьекте string2
        System.out.println("Строка".equals(string2)); //а так будет работать потому сравнивается строка (обьект) с другим обектом

        //сравнение ccылочных типов с null
        System.out.println(string1 != null);
        System.out.println(string2 == null);

        if (string2!= null) System.out.println(string2.equals("Строка")); //проверка наперед

        //конкатенация строк
        string1 = "JavaBob";
        string2 = "PythonJob";

        // 1 вариант
        String concatString = string1 + " :: " + string2; //способ через плюс // попадет в пулл //создается новая строчка
        System.out.println(concatString);

        // 2 способ //тут создается как бы 2 строчки и поэтому 2 пула памяти, но сылки нет к 1 строке, только к общей
        concatString = string1 .concat(" :: ").concat(string2); //
        System.out.println(concatString);

        //если операций конкатенации много или они происходят в цикле

        //StringBuilder - работает быстрее, но не используется в многопоточных программах
        //StringBuffer - работает медленнее, но используется в многопоточных программах (потокобезопасный)
        //они позволяют контатенировать строки без промежуточных


        StringBuilder sb = new StringBuilder(); // создаем метод куда будем накапливать данные
        //fori - вводит цикл
        for (int i = 0; i < 10; i++) {
            sb.append(i).append(" "); // в памяти строки не создаются, но накапливаются, обращаемся к обьекту и в него вкладываем значения
        }
        concatString = sb.toString(); //обращаемся к методу где накопилась строка из цикла и просим вывести и присвоить значение переменной
        System.out.println(concatString);


    }
}
